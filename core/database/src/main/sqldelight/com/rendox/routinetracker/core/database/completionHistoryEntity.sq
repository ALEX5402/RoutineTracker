import com.rendox.routinetracker.core.model.HistoricalStatus;
import kotlin.Int;
import kotlinx.datetime.LocalDate;

CREATE TABLE completionHistoryEntity (
    id INTEGER NOT NULL PRIMARY KEY,
    routineId INTEGER NOT NULL,
    date INTEGER AS LocalDate NOT NULL,
    status TEXT AS HistoricalStatus NOT NULL,
    currentScheduleDeviation INTEGER AS Int NOT NULL,
    FOREIGN KEY(routineId) REFERENCES routineEntity(id)
);

getHistoryEntriesByIndices:
SELECT *
FROM completionHistoryEntity
WHERE routineId = :routineId
    AND date BETWEEN :start AND :end
ORDER BY
        date ASC;

insertHistoryEntry:
INSERT INTO completionHistoryEntity
VALUES (?, ?, ?, ?, ?);

updateHistoryEntryStatusByDate:
UPDATE completionHistoryEntity
SET status = ?,
currentScheduleDeviation = ?
WHERE routineId = ? AND date = ?;

updateLastHistoryEntryStatusByStatus:
UPDATE completionHistoryEntity
SET status = :newStatus,
currentScheduleDeviation = :currentScheduleDeviation
WHERE id = (
    SELECT id
    FROM completionHistoryEntity
    WHERE routineId = :routineId AND status IN :statusPredicate
    ORDER BY date DESC
    LIMIT 1
);

findLastHistoryEntryByStatus:
SELECT *
FROM completionHistoryEntity
WHERE routineId = :routineId AND status IN :statusPredicate
ORDER BY date DESC
LIMIT 1;

getFirstHistoryEntryDateByStatus:
SELECT date
FROM completionHistoryEntity
WHERE routineId = :routineId
    AND (date >= :startDate)
    AND status IN :matchingStatuses
ORDER BY date ASC
LIMIT 1;

getFirstHistoryEntry:
SELECT *
FROM completionHistoryEntity
WHERE routineId = ?
ORDER BY date ASC
LIMIT 1;

getLastHistoryEntry:
SELECT *
FROM completionHistoryEntity
WHERE routineId = ?
ORDER BY date DESC
LIMIT 1;

deleteHistoryEntry:
DELETE FROM completionHistoryEntity
WHERE routineId = ? AND date = ?;
